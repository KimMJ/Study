# 스프링 컨테이너 및 설정 파일

스프링 프레임워크도 다른 컨테이너와 마찬가지로 자신이 관리할 클래스들이 등록된 XML 설정 파일이 필요함.

## 스프링 IoC 시작하기

### `<bean>`

* `<bean>` 엘리먼트는 클래스 하나당 하나의 `<bean>` 설정이 필요하다.
* `<bean>` 엘리먼트에서 가장 중요한 것은 class 속성값이다. 여기에 패키지 경로가 포함된 전체 클래스 경로를 지정해야 한다.
* 클래스 경로를 잘못 작성하는 것을 방지하기 위해 자동완성 기능을 사용하는 것을 추천.

### 스프링 컨테이너의 동작 순서

1. 클라이언트가 스프링 설정 파일을 로딩하여 컨테이너 구동
2. 스프링 설정 파일에 `<bean>` 등록된 객체 생성
3. getBean() 메소드로 특정 이름의 객체를 요청(Lookup)
4. 객체 반환

클라이언트 소스를 수정하지 않고도 요청할 객체를 수정할 수 있다.

### 스프링 컨테이너 종류

1. BeanFactory
	* 스프링 설정 파일에 등록된 `<bean>` 객체를 생성하고 관리하는 가장 기본적인 컨테이너 기능만 제공
	* Lazy Loading 방식 사용.
	* 사용할 일이 거의 없음
2. ApplicationContext
	* BeanFactory가 제공하는 `<bean>` 객체 관리 기능 외에도 트랜잭션 관리나 메시지 기반의 다국어 처리 등 다양한 기능 제공
	* 컨테이너가 구동되는 시점에 `<bean>` 등록된 클래스들을 객체 생성하는 pre-loading 방식 사용.
	* 웹 애플리케이션 개발도 지원함.
	* 대부분 ApplicationContext유형의 컨테이너 사용.
		* GenericXmlApplicationContext : XML 설정 파일을 로딩하여 구동
		* XmlWebApplicationContext : 웹 기반의 스프링 애플리케이션 개발시 사용

## 스프링 XML 설정

### `<bean>` 루트 엘리먼트

* 스프링 컨테이너는 `<bean>` 저장소에 해당하는 XML 설정 파일을 참조하여 `<bean>`의 생명주기를 관리하고 여러가지 서비스 제공.
* 가장 중요한 역할을 담당.
* 이 설정 파일을 정확하게 작성하고 관리하는 것이 중요.
* 스프링 설정파일 이름은 무엇이든 상관없지만 `<bean>`를 루트엘리먼트로 사용해야 함.
* `<bean>` 엘리먼트 시작 태그에 네임스페이스를 비롯한 XML 스키마 관련 정보가 설정됨.

### `<import>` 엘리먼트

* 여러가지 기능별로 XML을 나누어 설정하였을 때 이를 하나로 통합할 시 사용하는 엘리먼트

### `<bean>` 엘리먼트

* 스프링 설정파일에 클래스를 등록하려면 `<bean>` 엘리먼트 사용.
* 이 때, id, class 속성을 사용.
* id 속성은 생략가능하지만 class는 필수.
* class는 정확한 패키지 경로와 클래스 이름을 지정해야 함.
* 될 수 있으면 STS의 자동완성 기능을 이용하여 클래스를 정확하게 등록하기를 권장
* `<bean>` 객체를 위한 이름을 지정할 때 사용하는 속성이 id임.
* id 속성을 컨테이너로부터 `<bean>` 객체를 요청할 때 사용함. 따라서 반드시 유일해야함.
* id와 비슷한 기능을 하는 name도 있음. name은 이름 명명 규칙이 따로 없음.


### `<bean>` 엘리먼트 속성

1. init-method
	* 스프링 컨테이너는 클래스 객체를 생성할 때 default constructor를 호출.
	* 따라서 객체 생성 후 멤버 변수 초기화가 필요할 때, init-method가 필요함.
	* `init-method=""`
2. destroy-method
	* 마찬가지로 컨테이너가 객체를 삭제하기 전에 호출될 메소드를 지정할 수 있다.
	* `destroy-method=""`
3. lazy-init
	* 기본적으로는 pre-loading이 실행됨.
	* 클라이언트가 요청하는 시점에 생성하고 싶을 때 `lazy-init="true"` 를 설정
4. scope
	* singletone으로 생성하고 싶을 때 : `scope="singleton"`
	* 기본값이 singleton임.
	* 해당 bean이 요청될 때마다 매번 새로운 객체를 생성하려면 : `scope="prototype"`
